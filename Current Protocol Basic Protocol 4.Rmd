---
title: "Basic Protocol 4"
author: "Wenyan Li"
date: "2023-03-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Support script for basic protocol 4

```{r}
# load required packages
# load libraries
library(rstudioapi)
library(Seurat)
library(ggplot2)
library(tidyverse)
library(patchwork)
library(celldex)
library(SingleR)
library(harmony)
library(DoubletFinder)
library(SeuratWrappers)
library(monocle3)
library(slingshot)
library(colorRamps)
library(CellChat)

# set a seed to re-produce pseudorandom numbers
set.seed(99)

# Obtain the path of this rmarkdown file and assign it to object "get_path"
get_path <- dirname(rstudioapi::getSourceEditorContext()$path)

# Set "get_path" as Working Directory
setwd(get_path)

# load subsetted Seurat objects for Basic Protocol 3
load("Protocol 3 output/subsetted demo Seurat objects.RData")

# Save images and data to this folder
saveTo <- "Protocol 4 output"


```



```{r}
# Create a function to save output images

func_save_images <- function(image.object, # plot objects
                             image.name, # name of the plot
                             image.path, # path to save image
                             h = 8, # image height in inch
                             w = 15, # image width in inch
                             r = 300, # image resolution
                             isHeatmap = F # check if image is a Seurat heatmap
){
  
  ifelse(!dir.exists(image.path), 
         dir.create(image.path,
                    recursive = T), 
         FALSE)
  
  if(isHeatmap){
    
      for(i in seq_along(image.name)){
        temp.path <- paste(image.path,image.name[i], 
                           sep = "/")
        
        tiff(filename = paste(temp.path,
                              "tiff",
                              sep = "."),
             width = w, 
             height = h,
             res = r, 
             units = "in")
        
        image.object[[i]]
        dev.off()
      } # end of for 1st loop
    
  }else{
    
      for(i in seq_along(image.name)){
        temp.path <- paste(image.path,
                           image.name[i], 
                           sep = "/")
        
        ggsave(filename = paste(temp.path,
                                "tiff",
                                sep = "."), 
               plot =  image.object[[i]],
               width = w, 
               height = h, 
               units = "in", 
               dpi = r, 
               limitsize = FALSE)
        
      } # end of for 2nd loop
    
  } # end of if isHeatmap statement
  
}# end of func_save_images function



# The size of AbSeq panels varies, reduce the number 
# for ab_pc_num if your panel is smaller than 10.
func_quick_process <- function(demo_seurat,
                               ab_pc_num = 10, # number of PCA components to use for protein
                               rna_pc_num = 15, # number of PCA components to use for RNA
                               ab_reduction_res = 0.8, # cluster resolution for protein
                               rna_reduction_res = 0.8) # cluster resolution for RNA
  
     {
  
      # check if the Seurat object has protein assay
      if("AB" %in% Seurat::Assays(demo_seurat))
        
          {  
           Seurat::DefaultAssay(demo_seurat) <- 'AB'
  
           # Normalize and scale data
           demo_seurat <- demo_seurat %>% 
                          Seurat::NormalizeData()  %>% 
                          Seurat::FindVariableFeatures() %>% 
                          Seurat::ScaleData() 

	  # perform PCA
           demo_seurat <- Seurat::RunPCA(object = demo_seurat, 
                                         reduction.name = 'apca')

           # perform UMAP
           demo_seurat <- Seurat::RunUMAP(demo_seurat, 
                                          reduction = 'apca', 
                                          dims = 1:ab_pc_num, 
                                          assay = 'AB', 
                                          reduction.name = 'adt.umap',
			               reduction.key = 'adtUMAP_')

	  # Find clusters
           demo_seurat <- Seurat::FindNeighbors(demo_seurat, 
                                                reduction = "apca", 
                                                dims = 1:ab_pc_num)

           demo_seurat <- Seurat::FindClusters(demo_seurat, 
                                               resolution = ab_reduction_res, 
                                               graph.name = "AB_snn")

           } # end of if statement
  
     # Change default assay to RNA
     Seurat::DefaultAssay(demo_seurat) <- "RNA"

     # Calculate percentages of mitochondrial gene expression for every cell. If it is a
     #  targeted sequencing, then the output of this commend line is all zeros.
     demo_seurat <- Seurat::PercentageFeatureSet(demo_seurat, 
                                                 pattern = "^MT[-|.]", 
                                                 col.name = "percent.mt") 

     # find top most variant genes
     demo_seurat <- demo_seurat %>% 
                    Seurat::NormalizeData() %>% 
		                Seurat::FindVariableFeatures(., 
		                                             selection.method = "vst")

     # scale data
     demo_seurat <- Seurat::ScaleData(demo_seurat, 
                                      verbose = FALSE)

     # perform PCA
     demo_seurat <- Seurat::RunPCA(demo_seurat, 
                                   npcs = rna_pc_num, 
                                   verbose = FALSE)

     # perform UMAP
     demo_seurat <- Seurat::RunUMAP(demo_seurat, 
                                    reduction = "pca", 
                                    dims = 1:rna_pc_num)

     # Find clusters
     demo_seurat <- Seurat::FindNeighbors(demo_seurat, 
                                          reduction = "pca", 
                                          dims = 1:rna_pc_num)

     demo_seurat <- Seurat::FindClusters(demo_seurat, 
                                         resolution = rna_reduction_res)

     demo_seurat <- Seurat::BuildClusterTree(demo_seurat)

     # return Seurat object as output
     return(demo_seurat)

} # end of func_quick_process function



```



# 4.1 Cell annotation

4.1.1 Cell type annotation with singleR
```{r}

# cell type annotation

# download the reference data - The demo data was generated with human PBMCs.
# Therefore, Human Primary Cell Atlas Data is suitable for this demonstration.
hu_ref <- celldex::HumanPrimaryCellAtlasData()

# If first time running this script, the "celldex" package may ask you this
# question:

# /Users/(user name)/Library/Caches/org.R-project.R/R/ExperimentHub
#  does not exist, create directory? (yes/no): 

# type "yes" in the Console and continue.

# celldex also provides data sets for mouse tissues
# type celldex:: in the Rstudio console and hit "Tap" on the keyboard 
# to select other reference data sets

# example:
# mm_ref <- celldex::MouseRNAseqData()

# build function
func_get_annotation<- function(input_seurat)
  
     {
      DefaultAssay(input_seurat) <- "RNA"
      
      expr_matrix <- GetAssayData(input_seurat, 
                                  slot = "data", 
                                  assay = "RNA")
      
      cluster_id <- input_seurat@meta.data$seurat_clusters
  
      # Optional: annotate cells by groups
      prediction_by_cluster <-SingleR::SingleR(test = expr_matrix,
                           ref = hu_ref, # make sure reference data is correct
                           labels = hu_ref$label.main, # make sure reference data is correct
                           clusters = cluster_id)

      # Annotation cells individually  
      prediction_by_cell <- SingleR::SingleR(test = expr_matrix,
                           ref = hu_ref,  # make sure reference data is correct
                           labels = hu_ref$label.main) # make sure reference data is correct
      
      # Save SingleR results to the Seurat object
      input_seurat@misc[["SingleR_results"]] <- prediction_by_cell

      # Annotation results
      cell_labels <- prediction_by_cell$labels

      names(cell_labels) <- rownames(prediction_by_cell$labels)

      # add annotation information to Seurat object under meta.data
      input_seurat <- AddMetaData(input_seurat, 
                                  metadata = cell_labels,
                                  col.name = "cell_type")

      # make cell types with less than 10 cells as "unknown"
      temp <- table(input_seurat$cell_type)[table(input_seurat$cell_type) < 10] %>% 
                             names()
      
      input_seurat$cell_type[input_seurat$cell_type %in% temp] <- "unknow"
      
      # return Seurat object as output
      return(input_seurat)
      
} # end of func_get_annotation function

# use function to perform singleR cell type annotation
subset_demo_seurat_1 <- func_get_annotation(subset_demo_seurat_1)

subset_demo_seurat_2 <- func_get_annotation(subset_demo_seurat_2)



```



4.1.2 Results: Cell type annotation with SingleR

```{r}
# Cell type summary
table(subset_demo_seurat_1$cell_type)
```



```{r}
# Cell type summary
table(subset_demo_seurat_2$cell_type)
```



```{r}
# Cell annotation scores
p_cell_1 <- plotScoreHeatmap(subset_demo_seurat_1@misc$SingleR_results, 
                             show_colnames = F)

p_cell_2 <- plotScoreHeatmap(subset_demo_seurat_2@misc$SingleR_results, 
                             show_colnames = F)

func_save_images(image.object = list(p_cell_1, 
                                     p_cell_2),
                 image.name = c("Subset - heatmap of singleR annotation scores - demo 1", 
                                "Subset - heatmap of singleR annotation scores - demo 2"),
                 image.path = "Protocol 4 output",
                 h = 5,
                 w = 7,
                 r = 300,
                 isHeatmap = F
                 )

# Display cells in UMAP plot
p_cell_3 <- Seurat::DimPlot(subset_demo_seurat_1, 
                            group.by = "cell_type") + 
            ggtitle(Project(subset_demo_seurat_1))

p_cell_4 <- Seurat::DimPlot(subset_demo_seurat_2, 
                            group.by = "cell_type") + 
            ggtitle(Project(subset_demo_seurat_2))

patchwork::wrap_plots(p_cell_3 + 
                      p_cell_4)

func_save_images(image.object = list(patchwork::wrap_plots(p_cell_3 + 
                                                           p_cell_4)),
                 image.name = "Subset - UMAP group by cell type",
                 image.path = saveTo,
                 h = 5, 
                 w = 13, 
                 r = 300, 
                 isHeatmap = F
                 )


```



# 4.2 Merge datasets and remove batch effect

```{r}

# Merge experiments
levels(subset_demo_seurat_1$orig.ident) <- "demo1"
levels(subset_demo_seurat_2$orig.ident) <- "demo2"

subset_demo_combined <- merge(subset_demo_seurat_1, 
                              y = subset_demo_seurat_2, 
                              add.cell.ids = c("demo1", 
                                               "demo2"), 
                              project = "demo")

# Cluster cells
subset_demo_combined <- func_quick_process(subset_demo_combined)

# Check batch effect
p_cell_5 <- Seurat::DimPlot(subset_demo_combined, 
                            reduction = "umap", 
                    group.by = "orig.ident") +
                    ggtitle("before batch correction")

p_cell_6 <- Seurat::DimPlot(subset_demo_combined, 
                            reduction = "umap", 
                            split.by = "orig.ident", 
                            group.by = "cell_type") +
                    ggtitle("before batch correction")

# Use Harmony to negate the batch effect
# type ?harmony in the Rstuido console to find out more information
func_harmony<- function(seuratObj,
                        rna_pc_num = 15,
                        rna_reduction_res = 0.8)
      {
       Seurat::DefaultAssay(seuratObj) <- "RNA"

       seuratObj <- seuratObj %>% 
                    Seurat::NormalizeData() %>%
                    Seurat::FindVariableFeatures(., 
                                                 selection.method = "vst", 
                                                 nfeatures = 500)

       seuratObj <- Seurat::ScaleData(seuratObj, 
                                      verbose = FALSE)

       seuratObj <- Seurat::RunPCA(seuratObj, 
                                   npcs = rna_pc_num, 
                                   verbose = FALSE)

       seuratObj <- harmony::RunHarmony(seuratObj, 
                                        "orig.ident")

       seuratObj <- Seurat::RunUMAP(seuratObj, 
                                    reduction = "harmony", 
                                    dims = 1:rna_pc_num)

       seuratObj <- Seurat::FindNeighbors(seuratObj, 
                                          reduction = "harmony", 
                                          dims = 1:rna_pc_num)

       seuratObj <- Seurat::FindClusters(seuratObj, 
                                         resolution = rna_reduction_res)

       seuratObj <- Seurat::BuildClusterTree(seuratObj)

       # Return Seurat object
       return(seuratObj)
       
} # end of func_harmony function

# Perform batch effection correction
subset_demo_combined <- func_harmony(subset_demo_combined,
                                     rna_pc_num = 15,
                                     rna_reduction_res = 0.8)


```



4.2.1 Results: Merge datasets and remove batch effect

```{r}

p_cell_7 <- Seurat::DimPlot(subset_demo_combined, 
                            reduction = "umap", 
                    group.by = "orig.ident")  + 
                    ggtitle("after batch correction")

p_cell_8 <- Seurat::DimPlot(subset_demo_combined, 
                            reduction = "umap", 
                            split.by = "orig.ident", 
                            group.by = "cell_type")  +
                    ggtitle("after batch correction")

patchwork::wrap_plots(p_cell_5 + 
                      p_cell_7)

func_save_images(image.object = list(patchwork::wrap_plots(p_cell_5 + 
                                                           p_cell_7) + 
                                     plot_layout(guides = 'collect')),
                 image.name = "Subset - batch effect removal",
                 image.path = "Protocol 4 output",
                 h = 5, 
                 w = 11, 
                 r = 300, 
                 isHeatmap = F
                 )

patchwork::wrap_plots(p_cell_6 + 
                      p_cell_8)

func_save_images(image.object = list(patchwork::wrap_plots(p_cell_6 + 
                                                           p_cell_8) + 
                                     plot_layout(guides = 'collect')),
                 image.name = "Subset - batch effect removal - split",
                 image.path = "Protocol 4 output",
                 h = 8, 
                 w = 11, 
                 r = 300, 
                 isHeatmap = F
                 )


```



# 4.3 Find doublets with DoubletFinder

```{r}

# Find doublets

# BD provided doublet rates with different cell load numbers
rhapsody_doublet_rate <- data.frame(
                         "cell_num" = c(100,500,1000*(1:20)), 
                         "rate" = c(0, 0.1, 0.2, 0.5, 0.7, 1, 
                                    1.2, 1.4, 1.7, 1.9, 2.1, 
                                    2.4, 2.6, 2.8, 3.1, 3.3, 
                                    3.5, 3.8, 4, 4.2, 4.5 , 4.7))

# Build a linear model to calculate theoretical doublet rate
model_rhap <- lm(rate ~ cell_num, 
                 rhapsody_doublet_rate)

# define function
func_get_doublets <- function(seuratObj,
                              est_doublet_model = model_rhap,
                              pc = 1:15) # number of PC components to be used
     {
  
     DefaultAssay(seuratObj) <- "RNA"
  
     # Find pK values
     sweep.res.list <- paramSweep_v3(seuratObj, 
                                     PCs = pc, 
                                     sct = F)

     sweep.stats <- summarizeSweep(sweep.res.list, 
                                   GT = FALSE)
  
     bcmvn <- find.pK(sweep.stats)

     pK_bcmvn <- bcmvn$pK[which.max(bcmvn$BCmetric)] %>% 
                 as.character() %>% 
                 as.numeric()
  
     # estimate doublet rate based on cell number
     DoubletRate = predict(est_doublet_model, 
                   data.frame(cell_num = dim(seuratObj)[2]))/100
  
     nExp_poi <- round(DoubletRate*ncol(seuratObj)) 
     
     seuratObj <- doubletFinder_v3(seuratObj, 
                                   PCs = pc, 
                                   pN = 0.25, 
                                   pK = pK_bcmvn, 
                                   nExp = nExp_poi, 
                                   reuse.pANN = F, 
                                   sct = F)
  
     temp1 <- grepl("DF.classifications", 
                    colnames(seuratObj@meta.data), 
                    ignore.case = T)

     colnames(seuratObj@meta.data)[temp1] <- "doublet_check"

     seuratObj$doublet_check <- seuratObj$doublet_check
  
     # return output
     return(seuratObj)

} # end of function

# use function to find doublets
subset_demo_seurat_1 <- func_get_doublets(subset_demo_seurat_1,
                                          pc = 1:15)

subset_demo_seurat_2 <- func_get_doublets(subset_demo_seurat_2,
                                          pc = 1:15)

```



4.3.1 Results: Find doublets with DoubletFinders

```{r}

# Visualize the result
p_cell_9 <- DimPlot(subset_demo_seurat_1, 
                    group.by = "doublet_check") + 
            ggtitle(Project(subset_demo_seurat_1))

p_cell_10 <- DimPlot(subset_demo_seurat_2, 
                     group.by = "doublet_check") + 
             ggtitle(Project(subset_demo_seurat_2))

patchwork::wrap_plots(p_cell_9 + 
                      p_cell_10)

func_save_images(image.object = list(patchwork::wrap_plots(p_cell_9 + 
                                                           p_cell_10)),
                 image.name = "Subset - doublets",
                 image.path = saveTo,
                 h = 5, 
                 w = 11, 
                 r = 300, 
                 isHeatmap = F
                 )


```



# 4.4 Finding marker genes

```{r}


# Build function
func_get_marker_genes <- function(input_seurat,
                                  p_adj_cutoff = 0.05,
                                  log2FC_cutoff = 1,
                                  view_top_X_genes = 5)
  
{
  # Find marker genes for each cluster group against the rest
  Seurat::Idents(input_seurat) <- "seurat_clusters"
  
  cluster_DGE <- SeuratWrappers::RunPrestoAll(input_seurat, 
                                              assay = "RNA", 
                                              only.pos = FALSE, 
                                              verbose = FALSE)
  
  # Find marker genes for each cell type against the rest
  Seurat::Idents(input_seurat) <- "cell_type"
  
  Cell_type_DGE <- SeuratWrappers::RunPrestoAll(input_seurat, 
                                                assay = "RNA", 
                                                only.pos = FALSE, 
                                                verbose = FALSE)
  
  # example of taking the top X genes in each DGE group and removing the duplicates
  cluster_DGE <- cluster_DGE[abs(cluster_DGE$avg_log2FC) > log2FC_cutoff & 
                             cluster_DGE$p_val_adj < p_adj_cutoff, ]
  
  Cell_type_DGE <- Cell_type_DGE[abs(Cell_type_DGE$avg_log2FC) > log2FC_cutoff & 
                                 Cell_type_DGE$p_val_adj < p_adj_cutoff, ]
  
  top_genes_cluster <- cluster_DGE %>% 
    group_by(cluster)%>% 
    slice_max(n = view_top_X_genes, 
              order_by = avg_log2FC) %>% 
    dplyr::pull(gene) %>% 
    unique()
  
  top_genes_type <- Cell_type_DGE %>% 
    group_by(cluster)%>% 
    slice_max(n = view_top_X_genes, 
              order_by = avg_log2FC) %>% 
    dplyr::pull(gene) %>% 
    unique()
  
  # return output as a list
  return(list(DGEs_cluster = cluster_DGE, 
              DGEs_cell = Cell_type_DGE, 
              top_cluster_gene = top_genes_cluster, 
              top_cell_gene = top_genes_type))
  
} # end of function

# use function to get marker genes
subset_demo1_DGEs <- func_get_marker_genes(subset_demo_seurat_1,
                                           p_adj_cutoff = 0.05,
                                           log2FC_cutoff = 1,
                                           view_top_X_genes = 5) 

subset_demo2_DGEs <- func_get_marker_genes(subset_demo_seurat_2,
                                           p_adj_cutoff = 0.05,
                                           log2FC_cutoff = 1,
                                           view_top_X_genes = 5)



```



4.4.1 Results: Finding marker genes

```{r}
# display example results
subset_demo1_DGEs$top_cell_gene

```



```{r}
# display example results
subset_demo2_DGEs$top_cell_gene

```



```{r}
# visualise top genes on dotplot
p_cell_10 <- DotPlot(subset_demo_seurat_1, 
                     features = subset_demo1_DGEs$top_cell_gene, 
                     group.by = "cell_type") + 
             coord_flip() +
             RotatedAxis() +
             ggtitle("Subset Demo 1")

p_cell_11 <- DotPlot(subset_demo_seurat_2, 
                     features = subset_demo2_DGEs$top_cell_gene, 
                     group.by = "cell_type") + 
             coord_flip() +
             RotatedAxis() +
             ggtitle("Subset Demo 2")

patchwork::wrap_plots(p_cell_10 + p_cell_11)

func_save_images(image.object = list(patchwork::wrap_plots(p_cell_10 + p_cell_11)),
                 image.name = "Subset - top genes dot plot",
                 image.path = saveTo,
                 h = 12, 
                 w = 14, 
                 r = 300, 
                 isHeatmap = F
                 )

```



# 4.5 Pseudotime Analysis

4.5 (a) Monocle3 trajectory

```{r}

# Monocle3 trajectory analysis

# Define function
func_monocle3 <- function(input_seurat,
                          rna_pc_num = 50)
     {
      # covert Seurat to SingleCellExperiment object
      demo_cds <- SeuratWrappers::as.cell_data_set(input_seurat) 
      
      rowData(demo_cds)$gene_short_name <- rownames(input_seurat)
      
      demo_cds <- preprocess_cds(demo_cds, 
                                 num_dim = rna_pc_num)

      demo_cds <- monocle3::reduce_dimension(demo_cds)
      
      demo_cds <- monocle3::cluster_cells(cds = demo_cds, 
                                          cluster_method = "louvain")

      # Change parameter use_partition to TRUE to learn disjoint graph in each partition

      demo_cds <- monocle3::learn_graph(demo_cds, 
                                        use_partition = FALSE)

      Seurat::Idents(input_seurat) <- "cell_type"

      # This is just an example. Please define root cells that are biologically 
      # correct for your experiment.
      # Note: if ids is an empty object, then this function may generate error.
      # You can use this line instead:       

    	   # demo_cds <- monocle3::order_cells(demo_cds, reduction_method = "UMAP")

      # and remove the following three lines, 
      # "ids <- ..",
      # "root_id <- .." 
      # "demo_cds <- .."

      # for more information, please visit 
      # https://cole-trapnell-lab.github.io/monocle3/docs/trajectories/

      ids <- unique(input_seurat$cell_type) %>% 
             .[grep(paste("CMP", 
                          "GMP", 
                          "HSC", 
                          "CD34", 
                          "stem", 
                          "iPS",
                          sep = "|"),
                    ., 
                    ignore.case = T)]
      
      root_id <- colnames(subset(input_seurat, 
                          idents = ids))

      demo_cds <- monocle3::order_cells(demo_cds, 
                                        reduction_method = "UMAP", 
                                        root_cells = root_id)
      
      colData(demo_cds)$m3_pseudotime <- pseudotime(demo_cds)

      # return Seurat object
      return(demo_cds)
}

# use function to get results
subset_demo_cds_1 <- func_monocle3(subset_demo_seurat_1,
                                   rna_pc_num = 50)

subset_demo_seurat_1 <- Seurat::AddMetaData(
                                object = subset_demo_seurat_1,
                                metadata = pseudotime(subset_demo_cds_1),
                                col.name = "m3_pseudotime"
                                )

```



4.5.1 (a) Results: Monocle3 trajectory

```{r}
# Display results

# Check monocle3 trajectory
p_m3_pseudo_all <- plot_cells(subset_demo_cds_1,
                              color_cells_by = "pseudotime",
                              label_cell_groups=FALSE,
                              label_leaves=FALSE,
                              label_branch_points=FALSE,
                              graph_label_size=1.5) + 
                              ggtitle("All cells (UMAP done on Monocle3)")

p_m3_pseudo_tag1 <- plot_cells(subset_demo_cds_1[, grepl("SampleTag01_hs", 
                                                         colData(subset_demo_cds_1)$smk, 
                                                         ignore.case=TRUE)],
                               color_cells_by = "pseudotime",
                               label_cell_groups=FALSE,
                               label_leaves=FALSE,
                               label_branch_points=FALSE,
                               graph_label_size=1.5) +
                               ggtitle("SampleTag01_hs (UMAP done on Monocle3)")

p_m3_pseudo_tag2 <- plot_cells(subset_demo_cds_1[, grepl("SampleTag02_hs", 
                                                         colData(subset_demo_cds_1)$smk, 
                                                         ignore.case=TRUE)],
                               color_cells_by = "pseudotime",
                               label_cell_groups=FALSE,
                               label_leaves=FALSE,
                               label_branch_points=FALSE,
                               graph_label_size=1.5) +
                               ggtitle("SampleTag02_hs (UMAP done on Monocle3)")

wrap_plots(p_m3_pseudo_all + 
             p_m3_pseudo_tag1 + 
             p_m3_pseudo_tag2) + 

func_save_images(image.object = list(wrap_plots(p_m3_pseudo_all + 
                                                p_m3_pseudo_tag1 + 
                                                p_m3_pseudo_tag2)),
                 image.name = "Subset - monocle3 trajectory",
                 image.path = saveTo,
                 h = 5, 
                 w = 15, 
                 r = 300, 
                 isHeatmap = F
                 )


# Check pseudotime for different sample tags
Idents(subset_demo_seurat_1) <- "smk"

p_m3_celltype <- ggplot(subset(subset_demo_seurat_1, 
                               idents = c("SampleTag01_hs", 
                                          "SampleTag02_hs"))@meta.data, 
                        aes(x = m3_pseudotime, 
                            y = cell_type, 
                            colour = cell_type)) +
                        geom_point() +
                        geom_jitter(width = 0.1, 
                                    height = 0.2) +
                        theme_gray() +
                        theme(legend.position = "none") +
                        facet_grid(. ~ smk )

p_m3_celltype

func_save_images(image.object = list(p_m3_celltype),
                 image.name = "Subset - monocle3 pseudotime split by smk",
                 image.path = saveTo,
                 h = 5, 
                 w = 11, 
                 r = 300, 
                 isHeatmap = F
                 )


# Check pseudotime in Seuart UMAP embeddings
Idents(subset_demo_seurat_1) <- "smk"

p_m3_pseudo_umap <- Seurat::FeaturePlot(subset(subset_demo_seurat_1, 
                                        idents = c("SampleTag01_hs", 
                                                   "SampleTag02_hs")),  
                                        features = "m3_pseudotime") + 
                            ggtitle("All cells") & 
                            scale_color_viridis_c("m3_pseudotime")

p_m3_pseudo_umap

func_save_images(image.object = list(p_m3_pseudo_umap),
                 image.name = "Subset - monocle3 pseudotime (in Seurat) all cells",
                 image.path = saveTo,
                 h = 5, 
                 w = 6, 
                 r = 300, 
                 isHeatmap = F
                 )

p_m3_pseudo_umap_split <- Seurat::FeaturePlot(subset(subset_demo_seurat_1, 
                                                     idents = c("SampleTag01_hs", 
                                                                "SampleTag02_hs")),  
                                              features = "m3_pseudotime", 
                                              split.by = "smk") & 
                                              theme(legend.position="right") &
                                              scale_color_viridis_c("m3_pseudotime")

p_m3_pseudo_umap_split

func_save_images(image.object = list(p_m3_pseudo_umap_split),
                 image.name = "Subset - monocle3 pseudotime (in Seurat) split by smk",
                 image.path = saveTo,
                 h = 5, 
                 w = 13, 
                 r = 300, 
                 isHeatmap = F
                 )


# Display Cell types in Seurat UMAP
p_dim_umap <- Seurat::DimPlot( subset(subset_demo_seurat_1, 
                               idents = c("SampleTag01_hs", 
                                          "SampleTag02_hs")),
                               group.by = "cell_type",
                               split.by = "smk")  

p_dim_umap

func_save_images(image.object = list(p_dim_umap),
                 image.name = "Subset - monocle3 cell type check",
                 image.path = saveTo,
                 h = 5, 
                 w = 11, 
                 r = 300, 
                 isHeatmap = F
                 )

# Display pseudotime vs gene expression
p_pseudo_gene_1 <- FeatureScatter(subset(subset_demo_seurat_1,
                                         idents = c("SampleTag01_hs", 
                                                    "SampleTag02_hs")), 
                                  feature1 = "m3_pseudotime", 
                                  feature2  = "CD8A",
                                  group.by = "smk") +
                   ggtitle("")

p_pseudo_gene_2 <- FeatureScatter(subset(subset_demo_seurat_1,
                                         idents = c("SampleTag01_hs", 
                                                    "SampleTag02_hs")), 
                                  feature1 = "m3_pseudotime", 
                                  feature2  = "CD19",
                                  group.by = "smk") +
                   ggtitle("")

p_pseudo_gene_3 <- FeatureScatter(subset(subset_demo_seurat_1,
                                         idents = c("SampleTag01_hs", 
                                                    "SampleTag02_hs")), 
                                  feature1 = "m3_pseudotime", 
                                  feature2  = "NKG7",
                                  group.by = "smk") +
                   ggtitle("")

p_pseudo_gene <- wrap_plots(p_pseudo_gene_1 + 
                            p_pseudo_gene_2 + 
                            p_pseudo_gene_3) +
                 plot_layout(guides = "collect")

p_pseudo_gene

func_save_images(image.object = list(p_pseudo_gene),
                 image.name = "Subset - monocle3 pseudotime vs gene expression",
                 image.path = saveTo,
                 h = 5, 
                 w = 11, 
                 r = 300, 
                 isHeatmap = F
                 )



```



4.5 (b) Slingshot

```{r}

# Slingshot pseudotime analysis

# Define function
func_slingshot <- function(input_seurat)
     {
  
      # group cells at early states as start_clus
  
      # This is just an example. Please define root cells that are biologically 
      # correct for your experiment.
      # Note: if ids is an empty object, then this function may generate error.
      # You can use this line instead:       

    	   #    demo_sce <- slingshot::slingshot(demo_sce, 
            #                                     clusterLabels = "cell_type",
            #                                     reducedDim = "PCA", 
            #                                     allow.breaks = F)

      # and remove the following four lines, "Seurat::Idents(input_seurat) <- ..",
      # "ids <- ..."
      # "input_seurat$cell_type <- .." and 
      # "input_seurat$cell_type[input_seurat$cell_type %in% ids] <- .."

      # for more information, please visit 
      # http://www.bioconductor.org/packages/release/bioc/vignettes/slingshot/inst/doc/vignette.html
  
      Seurat::Idents(input_seurat) <- "cell_type"

      ids <- unique(input_seurat$cell_type) %>% 
             .[grep(paste("CMP", 
                          "GMP", 
                          "HSC", 
                          "CD34", 
                          "stem", 
                          "iPS", 
                          sep = "|"), 
               ., 
               ignore.case = T)]
      
      input_seurat$cell_type[input_seurat$cell_type %in% ids] <- "start_clus"
      
      # convert Seurat to SingleCellExperiment class
      demo_sce <- Seurat::as.SingleCellExperiment(input_seurat)
         
      # Perform slingshot analysis
      temp <- tryCatch(
        {
          
         # PCA, tSNE and UMAP are all accepted for slingshot analysis. 
         # However, PCA has more dimensions. Hence, it's recommended by Slingshot Author.
         
         # Subset first 6 PC components
         reducedDim(demo_sce, 
                    type = "PCA", 
                    WithDimnames = TRUE) <- reducedDim(demo_sce,
                                                       type = "PCA")[, 1:6]
          
         demo_sce <- slingshot::slingshot(demo_sce, 
                                clusterLabels = "cell_type",
                                start.clus = "start_clus",
                                reducedDim = "PCA", 
                                allow.breaks = F)
        },
        error = function(e){
          
         # if there is an issue with PC selection, switch reduction method to UMAP
         demo_sce <- slingshot::slingshot(demo_sce, 
                                clusterLabels = "cell_type",
                                start.clus = "start_clus",
                                reducedDim = "UMAP", 
                                allow.breaks = F)
          
        }
      )
      
      # return SCE object
      return(temp)

} # end of function

# use function to get results
subset_demo_slingshot_1 <- func_slingshot(subset_demo_seurat_1)

pt_lineages <- slingshot::slingPseudotime(subset_demo_slingshot_1)

# add Slingshot results to the input Seurat object
lineages <- sapply(slingLineages(colData(subset_demo_slingshot_1)$slingshot), 
                   paste, 
                   collapse = " -> ")

subset_demo_seurat_1@meta.data[lineages] <- pt_lineages


```



4.5.1 (b) Results: Slingshot

```{r}
# display results

# visualization

# display every lineage pseudotime
name_lineage <- colnames(subset_demo_seurat_1@meta.data)[grepl("->",
                                                               colnames(subset_demo_seurat_1@meta.data))]

p_ss_1 <- list()

Idents(subset_demo_seurat_1) <- "smk"

for (i in name_lineage) {
  
  p_ss_1[[i]] <- Seurat::FeaturePlot(subset(subset_demo_seurat_1, 
                                     idents = c("SampleTag01_hs", 
                                                "SampleTag02_hs")),  
                                     features = i, split.by = "smk") & 
                                     theme(legend.position="top") &
                                     scale_color_viridis_c() 
}

wrap_plots(p_ss_1, 
           ncol = 1)

func_save_images(image.object = list(wrap_plots(p_ss_1, 
                                                ncol = 1)),
                 image.name = "Subset - slingshot pseudotime (in Seurat) split by smk",
                 image.path = saveTo,
                 h = 30, 
                 w = 18, 
                 r = 300, 
                 isHeatmap = F
                 )



```



```{r}

# Display lineage curves
color <-  colorRamps::blue2green2red(length(unique(subset_demo_seurat_1$cell_type)))

names(color) <- unique(subset_demo_seurat_1$cell_type)

tiff(filename = paste(saveTo, 
                      "Subset - slingshot lineages.tiff",
                      sep = "/"), 
     compression = "lzw", 
     width = 6, 
     height = 5, 
     units = "in", 
     res = 300)

{
par(mar = c(6,4,6,12) + 0.1, 
    xpd = T)
  
plot(reducedDim(subset_demo_slingshot_1, "PCA"), 
     pch=16, 
     cex = 0.5, 
     col = color[as.character(subset_demo_seurat_1$cell_type)])

     title("Slingshot Lineages")

     legend("right",
            legend = names(color), 
            fill = color, 
            inset = c(-0.7,0))

     lines(SlingshotDataSet(colData(subset_demo_slingshot_1)$slingshot), 
           lwd = 2, 
           col = 'black', 
           type = 'lineages')
}

dev.off()


```



```{r}
# Check pseudotime for different sample tags

p_ss_celltype <- list()

Idents(subset_demo_seurat_1) <- "smk"

for (i in name_lineage) {
  
p_ss_celltype[[i]] <- ggplot(subset(subset_demo_seurat_1, 
                                    idents = c("Multiplet", 
                                               "Undetermined"), 
                                    invert = T)@meta.data, 
                        aes(x = .data[[i]], 
                        y = cell_type, 
                        colour = cell_type)) +
                        geom_point() +
                        geom_jitter(width = 0.1, 
                                    height = 0.2) +
                        theme_gray() +
                        theme(legend.position = "none") +
                        facet_grid(. ~ smk )
}

wrap_plots(p_ss_celltype, 
           ncol = 2)

func_save_images(image.object = list(wrap_plots(p_ss_celltype, 
                                                ncol = 1)),
                 image.name = "Subset - slingshot pseudotime split by smk",
                 image.path = saveTo,
                 h = 16, 
                 w = 8, 
                 r = 300, 
                 isHeatmap = F
                 )


```



4.6 CellChat

```{r}
# CellChat cell-cell communication analysis

# create function
func_cellchat <- function(input_seurat,
                          output_name)
     {
      # use cell type to grouop cells
      cc.object <- CellChat::createCellChat(object = input_seurat, 
                                            group.by = "cell_type")
 
      # if it is a mouse tissue, use CellChatDB.mouse
      cc.object@DB <- CellChat::CellChatDB.human 

      cc.object <- CellChat::subsetData(cc.object)
      
      cc.object <- CellChat::identifyOverExpressedGenes(cc.object)

      cc.object <- CellChat::identifyOverExpressedInteractions(cc.object)

      # cc.object <- CellChat::projectData(cc.object, PPI.human)

      cc.object <- CellChat::computeCommunProb(cc.object, 
                                               population.size = T, 
                                               raw.use = T)
 
      cc.object <- CellChat::computeCommunProbPathway(cc.object)

      cc.object <- CellChat::aggregateNet(cc.object)
      
      output <- CellChat::subsetCommunication(cc.object, 
                                              slot.name = "net")
      
      # Save the curated data to local drive
      temp_folder <- paste(saveTo, 
                           "CellChat output", 
                           sep = "/")

      ifelse(!dir.exists(file.path(temp_folder)), 
             dir.create(file.path(temp_folder)), FALSE)

      write.csv(x = output, 
                file = paste(temp_folder, 
                             paste0(output_name,".csv"), 
                             sep = "/"))

} # end of function

# use function to export files

# parameter "output_name" for function func_cellchat can any string, e.g. output_name <- "PBMCs_1".
# Here, Seurat project names are used.
func_cellchat(input_seurat = subset_demo_seurat_1, 
              output_name = Project(subset_demo_seurat_1))

func_cellchat(input_seurat = subset_demo_seurat_2, 
              output_name = Project(subset_demo_seurat_2))


```



Save subsetted Seurat objects

```{r}
# Save Seurat objects to local drive
save(subset_demo_seurat_1,
     subset_demo_seurat_2,
     subset_demo1_DGEs,
     subset_demo2_DGEs,
     subset_demo_combined,
     subset_demo_cds_1,
     subset_demo_slingshot_1,
     file = paste(saveTo, 
                  "subsetted demo Seurat objects (advanced analysis).RData", sep = "/")
     )


```








